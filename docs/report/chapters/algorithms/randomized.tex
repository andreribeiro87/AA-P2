\subsection{Randomized Algorithms}\label{sec:randomized}

Randomized algorithms use random choices during execution, offering a trade-off
between solution quality and computational
efficiency~\cite{motwani1995randomized}. Five randomized approaches for MWC are
implemented.

\subsubsection{Random Construction}\label{sec:random-construction}

The Random Construction heuristic builds cliques by randomly selecting vertices
that maintain the clique property. Starting from a random vertex, it
iteratively adds randomly chosen compatible vertices until no more can be
added.

\begin{algorithm}[H]
    \caption{Random Construction}
    \label{alg:random-construction}
    \footnotesize
    \scalebox{0.65}{
        \begin{minipage}{0.85\linewidth}
            \begin{algorithmic}[1]
                \Require Graph $G = (V, E)$, weights $w$, max\_iterations $T$
                \Ensure Best clique $C^*$ found
                \State $C^* \gets \emptyset$, $W^* \gets 0$
                \For{$t = 1$ to $T$}
                \State $v \gets$ \textsc{RandomChoice}($V$)
                \State $C \gets \{v\}$
                \State $candidates \gets V \setminus \{v\}$
                \While{$candidates \neq \emptyset$}
                \State $compatible \gets \{u \in candidates : \forall c \in C, (u,c) \in E\}$
                \If{$compatible = \emptyset$} \textbf{break} \EndIf
                \State $u \gets$ \textsc{RandomChoice}($compatible$)
                \State $C \gets C \cup \{u\}$, $candidates \gets candidates \setminus \{u\}$
                \EndWhile
                \If{$W(C) > W^*$} $C^* \gets C$, $W^* \gets W(C)$ \EndIf
                \EndFor
                \State \Return $C^*$
            \end{algorithmic}
        \end{minipage}
    }
\end{algorithm}

\textbf{Complexity Analysis:}
\begin{itemize}
    \item \textit{Time:} $O(T \cdot n^2)$ where $T$ is the number of iterations and $n = |V|$. Each iteration constructs a clique in $O(n^2)$ time (checking compatibility).
    \item \textit{Space:} $O(n)$ for storing the current clique and candidates.
\end{itemize}

\subsubsection{Random Greedy Hybrid}
\label{sec:random-greedy-hybrid}

This hybrid approach combines random exploration with greedy selection. Instead
of purely random choices, it probabilistically selects from the top-$k$
highest-weight compatible candidates.

\begin{algorithm}[H]
    \caption{Random Greedy Hybrid}
    \label{alg:random-greedy-hybrid}
    \footnotesize
    \scalebox{0.65}{
        \begin{minipage}{0.85\linewidth}
            \begin{algorithmic}[1]
                \Require Graph $G$, weights $w$, num\_starts $S$, top\_k $k$, randomness $\rho$
                \Ensure Best clique $C^*$ found
                \State $C^* \gets \emptyset$, $W^* \gets 0$
                \For{$s = 1$ to $S$}
                \State $v \gets$ \textsc{RandomChoice}($V$), $C \gets \{v\}$, $candidates \gets V \setminus \{v\}$
                \While{$candidates \neq \emptyset$}
                \State $compatible \gets \{(u, w(u)) : u \in candidates, \forall c \in C, (u,c) \in E\}$
                \If{$compatible = \emptyset$} \textbf{break} \EndIf
                \If{\textsc{Random}$(0,1) < \rho$} $u \gets$ \textsc{RandomChoice}($compatible$)
                \Else
                \State $top\_k \gets$ top $k$ elements of $compatible$ by weight
                \State $u \gets$ \textsc{WeightedRandomChoice}($top\_k$)
                \EndIf
                \State $C \gets C \cup \{u\}$, $candidates \gets candidates \setminus \{u\}$
                \EndWhile
                \If{$W(C) > W^*$} $C^* \gets C$, $W^* \gets W(C)$ \EndIf
                \EndFor
                \State \Return $C^*$
            \end{algorithmic}
        \end{minipage}
    }
\end{algorithm}

\textbf{Complexity Analysis:}
\begin{itemize}
    \item \textit{Time:} $O(S \cdot n^2 \log n)$ due to sorting candidates by weight.
    \item \textit{Space:} $O(n)$ for storing candidates and clique.
\end{itemize}

\subsubsection{Iterative Random Search}\label{sec:iterative-random-search}

Iterative Random Search generates random subsets of decreasing sizes and checks
if they form cliques. It starts with larger subsets (more likely to contain
maximum cliques) and progressively tests smaller ones.

\begin{algorithm}[H]
    \caption{Iterative Random Search}
    \label{alg:iterative-random-search}
    \footnotesize
    \scalebox{0.65}{
        \begin{minipage}{0.85\linewidth}
            \begin{algorithmic}[1]
                \Require Graph $G$, weights $w$, max\_iterations $T$, time\_limit
                \Ensure Best clique $C^*$ found
                \State $C^* \gets \emptyset$, $W^* \gets 0$, $size \gets n$
                \While{$size > 0$ and not timeout}
                \For{each iteration at current size}
                \State $S \gets$ \textsc{RandomSample}($V$, $size$)
                \If{\textsc{IsClique}($S$) and $W(S) > W^*$}
                \State $C^* \gets S$, $W^* \gets W(S)$
                \EndIf
                \EndFor
                \State $size \gets size - 1$
                \EndWhile
                \State \Return $C^*$
            \end{algorithmic}
        \end{minipage}
    }
\end{algorithm}

\textbf{Complexity Analysis:}
\begin{itemize}
    \item \textit{Time:} $O(T \cdot n^2)$ where checking each subset takes $O(n^2)$.
    \item \textit{Space:} $O(n)$ for storing subsets and tracking tested configurations.
\end{itemize}

\subsubsection{Monte Carlo Algorithm}
\label{sec:monte-carlo}

The Monte Carlo algorithm uses probabilistic sampling based on vertex weights.
Vertices with higher weights have greater probability of selection, potentially
finding heavy cliques quickly but without correctness guarantees.

\begin{algorithm}[H]
    \caption{Monte Carlo MWC}
    \label{alg:monte-carlo}
    \footnotesize
    \scalebox{0.65}{
        \begin{minipage}{0.85\linewidth}
            \begin{algorithmic}[1]
                \Require Graph $G$, weights $w$, num\_samples $N$, threshold $\tau$
                \Ensure Approximate clique $C^*$
                \State $C^* \gets \emptyset$, $W^* \gets 0$
                \State Compute probabilities $p(v) \propto w(v)$ for all $v \in V$
                \For{$i = 1$ to $N$}
                \State $C \gets \emptyset$, $available \gets V$
                \While{$available \neq \emptyset$}
                \State $probs \gets \{(v, p(v)) : v \in available, \forall c \in C, (v,c) \in E\}$
                \If{all probabilities are 0} \textbf{break} \EndIf
                \State $v \gets$ \textsc{WeightedRandomChoice}($probs$)
                \State $C \gets C \cup \{v\}$, $available \gets available \setminus \{v\}$
                \EndWhile
                \If{$W(C) > W^*$} $C^* \gets C$, $W^* \gets W(C)$ \EndIf
                \EndFor
                \State \Return $C^*$
            \end{algorithmic}
        \end{minipage}
    }
\end{algorithm}

\textbf{Complexity Analysis:}
\begin{itemize}
    \item \textit{Time:} $O(N \cdot n^2)$ for $N$ samples, each requiring $O(n^2)$ compatibility checks.
    \item \textit{Space:} $O(n)$ for probability distribution and clique storage.
\end{itemize}

\textbf{Note:} As a Monte Carlo algorithm, it may return suboptimal solutions even with high probability. The quality depends on the number of samples and the weight distribution.

\subsubsection{Las Vegas Algorithm}
\label{sec:las-vegas}

The Las Vegas algorithm guarantees correctness (always returns a valid clique)
but has variable runtime. It uses randomization to explore the solution space
while verifying each candidate at every step.

\begin{algorithm}[H]
    \caption{Las Vegas MWC}
    \label{alg:las-vegas}
    \footnotesize
    \scalebox{0.65}{
        \begin{minipage}{0.85\linewidth}
            \begin{algorithmic}[1]
                \Require Graph $G$, weights $w$, max\_attempts $A$, strategy
                \Ensure Valid clique $C^*$ (guaranteed correct)
                \State $C^* \gets \emptyset$, $W^* \gets 0$
                \For{$a = 1$ to $A$}
                \If{strategy = ``random\_walk''} $C \gets$ \textsc{RandomWalkClique}($G$)
                \Else~$C \gets$ \textsc{IterativeConstruction}($G$)
                \EndIf
                \If{\textsc{VerifyClique}($C$) and $W(C) > W^*$}
                \State $C^* \gets C$, $W^* \gets W(C)$
                \EndIf
                \EndFor
                \If{$C^* = \emptyset$} $C^* \gets \{\arg\max_{v \in V} w(v)\}$ \EndIf
                \State \Return $C^*$
            \end{algorithmic}
        \end{minipage}
    }
\end{algorithm}

\textbf{Complexity Analysis:}
\begin{itemize}
    \item \textit{Time:} $O(A \cdot n^2)$ expected, but can vary significantly.
    \item \textit{Space:} $O(n)$ for clique and verification data structures.
\end{itemize}

\textbf{Note:} Unlike Monte Carlo, Las Vegas always returns a valid clique. The trade-off is potentially longer runtime to find good solutions.

\subsubsection{Comparison of Randomized Approaches}

Table~\ref{tab:randomized-comparison} summarizes the key characteristics of the
randomized algorithms.

\begin{table}[H]
    \centering
    \caption{Comparison of Randomized Algorithms}
    \label{tab:randomized-comparison}
    \begin{tabular}{lccc}
        \toprule
        \textbf{Algorithm}   & \textbf{Correctness} & \textbf{Time}   & \textbf{Quality} \\
        \midrule
        Random Construction  & Guaranteed valid     & $O(Tn^2)$       & Variable         \\
        Random Greedy Hybrid & Guaranteed valid     & $O(Sn^2\log n)$ & Good             \\
        Iterative Random     & Guaranteed valid     & $O(Tn^2)$       & Poor             \\
        Monte Carlo          & May be invalid       & $O(Nn^2)$       & Good             \\
        Las Vegas            & Guaranteed valid     & Variable        & Good             \\
        \bottomrule
    \end{tabular}
\end{table}
