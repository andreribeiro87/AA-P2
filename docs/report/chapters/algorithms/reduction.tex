\subsection{Reduction-Based Algorithms}
\label{sec:reduction}

Reduction-based algorithms transform the MWC problem by preprocessing the graph
to reduce its size while preserving optimal solutions. These methods can
significantly improve performance on large sparse graphs.

\subsubsection{Graph Reduction Preprocessing}
\label{sec:mwc-redu}

MWCRedu applies polynomial-time reduction rules before solving the reduced
graph with another algorithm. The main rules include:

\begin{itemize}
    \item \textbf{Domination:} Vertex $u$ is dominated by $v$ if $N(u) \subseteq N(v) \cup \{v\}$ and $w(v) \geq w(u)$. Dominated vertices can be safely removed.
    \item \textbf{Isolation:} Isolated vertices (degree 0) cannot participate in cliques with other vertices.
    \item \textbf{Degree-based:} Vertices with very low degree and weight contribute little to potential cliques.
\end{itemize}
\begin{algorithm}[H]
    \caption{MWCRedu}
    \label{alg:mwc-redu}
    \footnotesize
    \scalebox{0.65}{
        \begin{minipage}{0.85\linewidth}
            \begin{algorithmic}[1]
                \Require Graph $G = (V, E)$, weights $w$, solver method
                \Ensure Maximum weight clique $C^*$
                \State $G' \gets G$, $mapping \gets$ identity
                \Repeat
                \State $changed \gets$ \textbf{false}
                \ForAll{$u \in V(G')$}
                \ForAll{$v \in V(G'), v \neq u$}
                \If{$w(v) \geq w(u)$ and $N(u) \subseteq N(v) \cup \{v\}$}
                \State Remove $u$ from $G'$, $changed \gets$ \textbf{true}, \textbf{break}
                \EndIf
                \EndFor
                \EndFor
                \State Apply isolation and degree rules
                \Until{not $changed$}
                \State $C' \gets$ \textsc{Solve}($G'$, solver)
                \State $C^* \gets$ map $C'$ back to original vertices
                \State \Return $C^*$
            \end{algorithmic}
        \end{minipage}
    }
\end{algorithm}

\textbf{Complexity Analysis:}
\begin{itemize}
    \item \textit{Reduction Phase:} $O(n^3)$ worst case for domination checking across all vertex pairs, iterated until convergence.
    \item \textit{Total Time:} $O(n^3 + T_{solver}(n'))$ where $n'$ is the reduced graph size.
    \item \textit{Space:} $O(n + m)$ for storing the reduced graph and mappings.
\end{itemize}

\subsubsection{Branch-and-Bound with Coloring Bounds}
\label{sec:max-clique-weight}

MaxCliqueWeight uses branch-and-bound with weighted graph coloring to compute
upper bounds. The key insight is that vertices in a clique must have different
colors, so the sum of maximum weights per color class bounds the maximum clique
weight.
\begin{algorithm}[H]
    \caption{MaxCliqueWeight}
    \label{alg:max-clique-weight}
    \footnotesize
    \scalebox{0.65}{
        \begin{minipage}{0.85\linewidth}
            \begin{algorithmic}[1]
                \Require Graph $G$, weights $w$, variant (static/dynamic)
                \Ensure Maximum weight clique $C^*$
                \State Order vertices by weight (descending)
                \State $C^* \gets \emptyset$, $W^* \gets 0$, $coloring \gets$ \textsc{WeightedColoring}($V$)
                \Procedure{Search}{$C$, $candidates$, $W$}
                \If{$candidates = \emptyset$}
                \If{$W > W^*$} $C^* \gets C$, $W^* \gets W$ \EndIf
                \State \Return
                \EndIf
                \If{variant = ``dynamic''} $UB \gets$ \textsc{ComputeColoringBound}($candidates$)
                \Else~$UB \gets$ precomputed bound for $candidates$
                \EndIf
                \If{$W + UB \leq W^*$} \Return \EndIf
                \ForAll{$v \in candidates$ in order}
                \If{$v$ is compatible with $C$}
                \State $newCandidates \gets \{u \in candidates : (v,u) \in E\}$
                \State \textsc{Search}($C \cup \{v\}$, $newCandidates$, $W + w(v)$)
                \EndIf
                \EndFor
                \EndProcedure
                \State \textsc{Search}($\emptyset$, $V$, $0$)
                \State \Return $C^*$
            \end{algorithmic}
        \end{minipage}
    }
\end{algorithm}

\textbf{Complexity Analysis:}
\begin{itemize}
    \item \textit{Time:} $O(2^n)$ worst case (exponential), but pruning significantly reduces practical complexity.
    \item \textit{Space:} $O(n^2)$ for coloring data structures and recursion stack.
\end{itemize}

\subsubsection{MaxCliqueDynWeight: Dynamic Bound Recomputation}
\label{sec:max-clique-dyn-weight}

MaxCliqueDynWeight is a variant of MaxCliqueWeight that dynamically recomputes
upper bounds at each node of the search tree. While more expensive per node,
tighter bounds lead to more aggressive pruning.

\begin{algorithm}[H]
    \caption{MaxCliqueDynWeight (Dynamic Variant)}
    \label{alg:max-clique-dyn-weight}
    \footnotesize
    \scalebox{0.65}{
        \begin{minipage}{0.85\linewidth}
            \begin{algorithmic}[1]
                \Require Graph $G$, weights $w$
                \Ensure Maximum weight clique $C^*$
                \State Same as Algorithm~\ref{alg:max-clique-weight} with variant = ``dynamic''
                \State At each search node, recompute coloring for remaining candidates
                \State \Return $C^*$
            \end{algorithmic}
        \end{minipage}
    }
\end{algorithm}

\textbf{Complexity Analysis:}
\begin{itemize}
    \item \textit{Time:} $O(2^n \cdot n^2)$ worst case due to recomputing coloring at each node.
    \item \textit{Space:} $O(n^2)$ for dynamic coloring computation.
\end{itemize}

\textbf{Trade-off:} Dynamic recomputation provides tighter bounds but increases per-node cost. Effective on dense graphs where static bounds are loose.

\begin{table}[H]
    \centering
    \caption{Comparison of Reduction-Based Algorithms}\label{tab:reduction-comparison}
    \scalebox{0.8}{
        \begin{tabular}{lccc}
            \toprule
            \textbf{Algorithm} & \textbf{Guarantees} & \textbf{Time}         & \textbf{Best For} \\
            \midrule
            MWCRedu            & Optimal*            & $O(n^3 + T_{solver})$ & Large sparse      \\
            MaxCliqueWeight    & Optimal             & $O(2^n)$              & Medium graphs     \\
            MaxCliqueDynWeight & Optimal             & $O(2^n \cdot n^2)$    & Dense graphs      \\
            \bottomrule
        \end{tabular}
    }

    \vspace{2pt}
    {\centering \small{*MWCRedu optimality depends on the underlying solver.}\par}
\end{table}

