\subsection{Algoritmo Exaustivo (Baseline Ótimo)}\label{subsec:exaustivo}

O algoritmo exaustivo encontra a solução ótima testando sistematicamente todos os possíveis subconjuntos de vértices.
Esta abordagem garante optimalidade, mas possui complexidade exponencial, sendo um baseline fundamental adequado apenas para instâncias pequenas.
\begin{algorithm}[H]
    \caption{Algoritmo Exaustivo para Maximum Weight Clique}
    \begin{algorithmic}[1]
        \Require Grafo $G(V,E)$ com pesos positivos nos vértices $w: V \to \mathbb{R}^+$
        \Ensure Clique de peso máximo $(best\_clique, best\_weight)$
        \Ensure Métricas de execução $(operations, configurations)$
        \State $best\_clique \leftarrow \emptyset$
        \State $best\_weight \leftarrow 0$
        \State $operations \leftarrow 0$
        \State $configurations \leftarrow 0$
        \For{cada subconjunto $S \subseteq V$}
        \State $configurations \leftarrow configurations + 1$
        \State $is\_clique, checks \leftarrow$ verificar se $S$ é clique
        \State $operations \leftarrow operations + checks$
        \If{$is\_clique$}
        \State $weight \leftarrow \sum_{v \in S} w(v)$
        \If{$weight
                > best\_weight$}
        \State $best\_clique \leftarrow S$
        \State $best\_weight \leftarrow weight$
        \EndIf
        \EndIf
        \EndFor
        \\
        \Return $($ \par
        \hspace{1.5em} $best\_clique,$ \par
        \hspace{1.5em} $best\_weight,$ \par
        \hspace{1.5em} $operations,$ \par
        \hspace{1.5em} $configurations$ \par
        $)$
    \end{algorithmic}
\end{algorithm}

O algoritmo percorre todos os $2^n$ subconjuntos possíveis de vértices.
Para cada subconjunto $S$, verifica se forma um clique testando todas as arestas entre pares de vértices em $S$.
Se $S$ for um clique válido, calcula o seu peso total e actualiza a melhor solução encontrada caso o peso seja superior.
\subsubsection{Análise de Complexidade}

\textbf{Complexidade Temporal:} $O(2^n \times n^2)$

\begin{itemize}
    \item Existem $2^n$ subconjuntos possíveis de vértices a testar.
    \item Para cada subconjunto $S$ com $|S| = k$, a verificação de clique requer $\binom{k}{2} = \frac{k(k-1)}{2}$ verificações de adjacência.
    \item No pior caso, quando $k = n$, temos $\binom{n}{2} = O(n^2)$ verificações por subconjunto.
    \item Portanto, o tempo total é $O(2^n \times n^2)$.
\end{itemize}

\textbf{Complexidade Espacial:} $O(n)$

O espaço necessário é apenas para armazenar o melhor clique encontrado, que contém no máximo $n$ vértices.
A geração de subconjuntos pode ser feita iterativamente sem necessidade de armazenar todos simultaneamente.

\textbf{Correção:} O algoritmo é correto pois testa todos os possíveis cliques e mantém o de maior peso.
Como explora todo o espaço de soluções, garante encontrar a solução ótima.

\textbf{Limitações Práticas:} Devido ao crescimento exponencial, este algoritmo torna-se impraticável para grafos com mais de aproximadamente 20 vértices. É crucial notar que esta barreira de $n \approx 20$ é uma limitação da força bruta, não da resolução exata moderna.

\subsubsection{Abordagens Exatas Estado-da-Arte (SOTA)}
A investigação SOTA não utiliza a enumeração $O(2^n \times n^2)$. Em vez disso, emprega duas estratégias principais que são ordens de magnitude mais rápidas:
\begin{itemize}
    \item \textbf{Branch-and-Bound (B\&B):} Algoritmos como o \texttt{MaxCliqueWeight} \cite{konc2025efficient} exploram a árvore de busca $2^n$ de forma inteligente. Utilizam métodos de coloração de grafos ponderados para calcular um upper bound (limite superior) para o peso da clique num ramo. Se este upper bound for inferior à melhor clique já encontrada (lower bound), o ramo inteiro é "podado" (pruned).
    \item \textbf{Redução de Dados (Data Reduction):} Algoritmos como o \texttt{MWCRedu} \cite{erhardt2023improved} aplicam um pré-processamento agressivo em tempo polinomial. Utilizam regras baseadas na estrutura local (e.g., remoção de vértices dominados) para reduzir o tamanho do grafo de $n$ para $n' \ll n$, preservando a solução ótima. O solver B\&B é então executado neste grafo muito mais pequeno.
\end{itemize}
Estas técnicas SOTA são capazes de resolver exatamente instâncias consideravelmente maiores do que o limite de $n \approx 20$ da força bruta.